Tema1 PA

Implementare:

Problema 1 - feribot

Ideea de rezolvare:
- deoarece trebuie gasit costul cel mai bun intr un mod cat mai eficient,
cea mai buna idee dupa parerea mea ar fi un binary search intr un interval
de costuri posibile (complexitate O(log n))
- astfel, la capatul din stanga (cea mai mica valoare) se poate alege costul
maxim (greutatea maxima) al unei masini deoarece in orice caz vom avea costul
final cel mai mic (optim) pornind de la acesta (in cel mai bun caz in care 
numarul de feriboturi este >= numarul de masini, raspunsul va fi greutatea cea
mai mare a tuturor masinilor (1 masina per feribot) )
exemplu : cost 1 2 3 si 1 feribot => costul final este 6
                        2 feriboturi => costul final este 3
                        3  feriboturi => costul final este 3
                        4,5 ... => costul final este 3
- in capatul din dreapta va fi suma totala a greutatilor (in cel mai rau caz in
care avem un singur feribot si trebuie sa punem toate masinile in el)
- in binary search vom verifica de fiecare data daca costul final distribuit 
uniform pe toate feriboturile este optim astfel
                        * daca nu s au parcurs toate masinile, trebuie marit
                        costul de transport al feriboturilor
                        * daca s au parcurs toate masinile, se scade din costul
                        de transport al feriboturilor

Partea de cod:
- am copiat din scheletul celorlalte probleme functia de citire a
elementelor unui vector deoarece era necesar sa citesc fiecare
greutate a unei masini, modificand tipul vectorului la int64_t pentru
a fi sigur ca se citesc bine si valori foarte mari ale greutatii unei
masini
- in functia main se citesc intai N (numarul de masini) si K (numarul
de feriboturi), apoi toate cele N greutati ale masinilor ; se face
suma greutatilor si greutatea maxima pentru a fi apelata functia 
find_C care primeste aceste 2 capete pentru care sa faca un binary search
si intoarce rezultatul optim al problemei
- in functia find_C e implementarea unui binary search care calculeaza 
la fiecare pas costul optim C si verifica daca toate masinile au fost
parcurse (adaugate in nr total de feriboturi) ; daca s au parcurs toate
masinile, inseamna ca putem avea o solutie mai buna, deci actualizam 
maximul la C (valoarea curenta) si iteram mai departe ; daca nu, trebuie
incrementata valoarea optima (capatul din stanga), cu speranta de a adauga
intr un final toate masinile

Problema 2 - nostory

FUNCTIA DE SORTARE MERGE SORT E PRELUATA DIN LAB!!

Ideea de rezolvare:
- la primul task ideea este ca la un numar nelimitat de mutari scorul 
maxim se va obtine prin insumarea primelor N celor mai mari numere
din cele doua liste deoarece fiecare maxim din cele 2 N va fi cuplat
cu celelalte N minime
- la al doilea task daca avem K mutari acele K mutari se vor obtine 
prin schimbarea celui mai mic maxim cu cel mai mare minim (daca
diferenta este pozitiva (este o mutare buna))

Partea de cod:
- in functia main se citesc datele corespunzatoare si se apeleaza
functia specifica taskului
- in functia task1 adaug intr un vector toate cele 2 * N elemente
si il sortez ca sa pot calcula suma primelor N cele mai mari numere
- in functia task2 aflu fiecare minim si maxim al tuturor perechilor
pentru a face k mutari in care adaug diferenta dintre ele intr un 
acumulator daca mutarea este buna (diferenta dintre ele sa fie pozitiva)
- complexitatea generala ar fi un O(nlogn) de la merge sort 

Problema 3 - sushi

FUNCTIA DE RUCSAC E PRELUATA DIN LAB!!

Ideea de rezolvare:
- problema se muleaza de fapt pe problema rucsacului cu volum infinit
la task1 si task2, astfel se poate aplica algoritmul corespunzator 
prezentat si in laborator
- la task ul 3, se mai adauga inca o dimensiune pentru a tine evidenta
si la un numar N de obiecte care se pun in ghiozdan

Partea de cod:
- in main se citeste si se apeleaza fiecare functie conform cerintei
- in functia task1 se face media notelor pentru fiecare platou ce va
reprezenta valoarea, iar pretul fiecarui platou reprezinta costul
- in functia task2 lucrurile se prezinta la fel ca la task1 doar ca 
se dubleaza numarul de platouri
- in functia task3 se mai adauga o dimensiune a matricii care tine
evidenta celor N obiecte maxim care pot fi adaugate
- la task1 si task2 complexitatea ar fi O(n * W)
- la task3 complexitatea ar fi O(n * W * Z)

Problema 4 - semnale

Ideea de rezolvare:
- problema se rezolva folosind programare dinamica, utilizand o
relatie de recurenta intre pasul actual si pasul anterior
- pentru primul task, relatia de recurenta e urmatoarea:
    * nr de biti actual cu fix k de 1 = nr biti precent cu fix k de 1 +
                            + nr de biti anteprecedent cu fix (k - 1) de 1
    deoarece putem sa mai adaugam un 0 la toate stringurile cu fix k de 1
    sau putem sa mai adaugam un 10 la toate stringurile de lungime n - 2
    cu fix (k - 1) de 1
- pentru al doilea task, relatia de recurenta e urmatoarea:
    * nr de biti actual cu fix k de 1 = nr biti precent cu fix k de 1 +
                            + nr de biti anteprecedent cu fix (k - 1) de 1
                            + nr de biti anteanteprecent cu fix (k - 2) de 1
    deoarece putem sa mai adaugam un 0 la toate stringurile precedente cu 
    fix k de 1 sau putem sa mai adaugam un 10 la toate stringurile ante
    cu fix k - 1 de 1 sau putem sa mai adaugam un 110 la toate stringurile
    de lungime n - 3 cu fix k - 2 de 1

Partea de cod:
- la ambele task uri se construieste matricea dp si se initializeaza valorile
de baza
- la task1 deoarece este o recurenta de 2 pasi, se declara cazuri de baza primii
2 termeni, la taskul2 primii 3 termeni
- se fac operatiile necesare folosind proprietatile % modulo pentru numerele f mari
- complexitatea este O(n * k) unde n este lungimea sirului si k este numarul de 1,
fiind data de parcurgerea recurentei de catre cele 2 for uri

Problema 5 - badgpt

FUNCTIA DE EXPONENTIERE E INSPIRATA DIN LAB!!

Ideea de rezolvare:
- se observa la o scurta privire ca rezultatul obtinut la incrementarea nr de litere
respecta sirul lui Fibonnaci
- astfel, totul se rezuma la aflarea numarului n al lui Fibonaci pentru cele n litere
consecutive de n sau u
- pentru a rezolva asta intr un mod eficient, se poate folosi ridicarea la putere a
matricei Fibonacci folosind metoda de ridicare de la lab (exponentierea logaritmica)
(A la a 4 a = A la 2 a ori A la a 2 a)

Partea de cod:
- se apeleaza functia find_fibo
- se returneaza cazurile de baza
- se defineste o functie auxiliara pentru inmultirea a 2 matrice
- se foloseste functia de exponentiere de la lab pentru calcul
